import ErrorCard from "@/components/error-card";
import ErrorLine from "@/components/error-line";
import { DomainCard } from "@/components/service/panel/content/undeployed/domain-card";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input, InputProps } from "@/components/ui/input";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Slider, SliderProps } from "@/components/ui/slider";
import TextareaWithTokens, { TTextareaWithTokensProps } from "@/components/ui/textarea-with-tokens";
import { cn } from "@/components/ui/utils";
import { appLocale } from "@/lib/constants";
import {
  AnyFieldApi,
  createFormHook,
  createFormHookContexts,
  useStore,
} from "@tanstack/react-form";
import { CheckIcon, RotateCcwIcon } from "lucide-react";
import { FC, ReactNode, useCallback, useMemo, useRef, useState } from "react";
import { z } from "zod";

const { fieldContext, formContext } = createFormHookContexts();

type TFieldProps = {
  field: AnyFieldApi;
  hideError?: boolean;
  dontCheckUntilSubmit?: boolean;
  classNameInput?: string;
  classNameInfo?: string;
};

type TInputWithInfoProps = TFieldProps & InputProps;

function InputWithInfo({
  className,
  hideError,
  field,
  classNameInput,
  classNameInfo,
  dontCheckUntilSubmit,
  showUndo,
  onUndo,
  Icon,
  classNameIcon,
  ...rest
}: TInputWithInfoProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;
  const ref = useRef<HTMLInputElement>(null);
  const inputRef = rest.ref || ref;

  return (
    <div className={cn("relative flex flex-col", className)}>
      {Icon && (
        <Icon
          className={cn("pointer-events-none absolute top-3 left-3.5 size-4.5", classNameIcon)}
        />
      )}
      <Input
        ref={inputRef}
        {...rest}
        data-show-undo={showUndo ? true : undefined}
        className={cn("w-full data-show-undo:pr-11", Icon && "pl-10", classNameInput)}
      />
      {showUndo && (
        <Button
          variant="ghost"
          className="absolute top-1 right-1 z-10 size-8.5 rounded-md"
          size="icon"
          onClick={() => {
            onUndo?.();
            ref.current?.focus();
          }}
        >
          <RotateCcwIcon className="size-4.5" />
        </Button>
      )}
      {!hideError &&
      (field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

function TextareaWithTokensWithInfo<T>({
  className,
  hideError,
  field,
  classNameInput,
  classNameInfo,
  dontCheckUntilSubmit,
  ...rest
}: TTextareaWithTokensProps<T> & TFieldProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;

  if (hideError) {
    return <TextareaWithTokens {...rest} className={cn("w-full", className, classNameInput)} />;
  }

  return (
    <div className={cn("flex flex-col", className)}>
      <TextareaWithTokens {...rest} className={cn("w-full", classNameInput)} />
      {(field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

type TDomainInputWithInfoProps = TFieldProps &
  InputProps & {
    autoGeneratedDomain?: string;
    hideCard?: boolean;
  };

function DomainInput({
  className,
  hideError,
  field,
  classNameInput,
  classNameInfo,
  dontCheckUntilSubmit,
  autoGeneratedDomain,
  hideCard,
  Icon,
  classNameIcon,
  ...rest
}: TDomainInputWithInfoProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;

  const showCardType =
    autoGeneratedDomain !== undefined && field.state.value === autoGeneratedDomain
      ? "auto-generated"
      : "domain-card";

  const showReset = autoGeneratedDomain !== undefined && field.state.value !== autoGeneratedDomain;

  const ref = useRef<HTMLInputElement>(null);

  return (
    <div className={cn("relative flex flex-col", className)}>
      {Icon && (
        <Icon
          className={cn(
            "pointer-events-none absolute top-3 left-3.5 z-[11] size-4.5",
            classNameIcon,
          )}
        />
      )}
      <Input
        ref={ref}
        {...rest}
        data-show-reset={showReset ? true : undefined}
        data-show-generated={showCardType === "auto-generated" ? true : undefined}
        className={cn(
          "relative z-10 w-full data-show-generated:pr-22 data-show-reset:pr-11",
          Icon && "pl-10",
          classNameInput,
        )}
      />
      {!rest.disabled && showReset && (
        <Button
          variant="ghost"
          className="absolute top-1 right-1 z-10 size-8.5 rounded-md focus-visible:z-10"
          size="icon"
          onClick={() => {
            field.setValue(autoGeneratedDomain);
            ref.current?.focus();
          }}
        >
          <RotateCcwIcon className="size-4.5" />
        </Button>
      )}
      {!hideCard && !rest.disabled && showCardType === "domain-card" && (
        <DomainCard domain={field.state.value} className="-mt-3 rounded-t-none pt-2.75" />
      )}
      {!rest.disabled && showCardType === "auto-generated" && (
        <AutoGeneratedDomainIndicator className="absolute top-4 right-1.25 z-10" />
      )}
      {!hideError &&
      (field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

function AutoGeneratedDomainIndicator({ className }: { className?: string }) {
  return (
    <div
      className={cn(
        "text-muted-foreground bg-background pointer-events-none relative flex max-w-1/2 min-w-0 items-center gap-1 rounded-sm border px-1.25 py-0.5",
        className,
      )}
    >
      <p className="min-w-0 shrink truncate text-xs leading-tight font-medium">Generated</p>
    </div>
  );
}

type TSliderWithInfoProps = TFieldProps &
  SliderProps & {
    classNameMin?: string;
    classNameMax?: string;
    minMaxFormatter?: (value: number) => string;
    hideMinMax?: boolean;
  };

function StorageSizeInput({
  className,
  hideError,
  field,
  classNameInput,
  classNameInfo,
  dontCheckUntilSubmit,
  classNameMin,
  classNameMax,
  minMaxFormatter,
  hideMinMax,
  ...rest
}: TSliderWithInfoProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;
  const classNameMinMax = "min-w-0 text-muted-foreground shrink leading-tight text-xs font-medium";

  const Min = useCallback(() => {
    if (rest.min === undefined || hideMinMax) return null;
    return (
      <p className={cn(classNameMinMax, classNameMin)}>
        {minMaxFormatter ? minMaxFormatter(rest.min) : rest.min.toLocaleString(appLocale)}
      </p>
    );
  }, [classNameMinMax, classNameMin, minMaxFormatter, rest.min, hideMinMax]);

  const Max = useCallback(() => {
    if (rest.max === undefined || hideMinMax) return null;
    return (
      <p className={cn(classNameMinMax, classNameMax)}>
        {minMaxFormatter ? minMaxFormatter(rest.max) : rest.max.toLocaleString(appLocale)}
      </p>
    );
  }, [classNameMinMax, classNameMax, minMaxFormatter, rest.max, hideMinMax]);

  return (
    <div className={cn("flex flex-col", className)}>
      <div className="flex w-full gap-3">
        <Min />
        <Slider {...rest} className={cn("flex-1", classNameInput)} />
        <Max />
      </div>
      {!hideError &&
      (field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("mt-1 bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

export type TCommandItem = {
  value: string;
  label: string;
};

type TAsyncCommandDropdownProps = TFieldProps & {
  items: TCommandItem[] | undefined;
  isPending: boolean;
  error: string | undefined;
  commandEmptyText: string;
  commandInputPlaceholder: string;
  CommandEmptyIcon: FC<{ className?: string }>;
  CommandItemElement?: FC<{ item: TCommandItem; className?: string }>;
  CommandItemsPinned?: FC<{ setIsOpen: (isOpen: boolean) => void; commandValue: string }>;
  TriggerWrapper?: FC<{
    isOpen: boolean;
    setIsOpen: (isOpen: boolean) => void;
    children: ReactNode;
  }>;
  className?: string;
  classNameInfo?: string;
  value: string;
  onChange: (value: string) => void;
  children: ({ isOpen }: { isOpen: boolean }) => ReactNode;
  commandInputValue?: string;
  commandInputValueOnChange?: (value: string) => void;
  commandShouldntFilter?: boolean;
};

const placeholderArray = Array.from({ length: 10 }, (_, index) => index);

function AsyncCommandDropdown({
  field,
  items,
  isPending,
  error,
  commandEmptyText,
  commandInputPlaceholder,
  CommandEmptyIcon,
  CommandItemElement,
  CommandItemsPinned,
  TriggerWrapper,
  dontCheckUntilSubmit,
  hideError,
  classNameInfo,
  value,
  onChange,
  className,
  children,
  commandInputValue,
  commandInputValueOnChange,
  commandShouldntFilter,
}: TAsyncCommandDropdownProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;

  const [isOpen, setIsOpen] = useState(false);
  const [commandValue, setCommandValue] = useState(value);
  const scrollAreaRef = useRef<HTMLDivElement>(null);

  const { shouldFilter, filter } = useMemo(() => {
    if (commandShouldntFilter || isPending) {
      return { shouldFilter: false, filter: () => 1 };
    }
    return { shouldFilter: undefined, filter: undefined };
  }, [isPending, commandShouldntFilter]);

  return (
    <div className={cn("flex flex-col", className)}>
      {TriggerWrapper ? (
        <TriggerWrapper isOpen={isOpen} setIsOpen={setIsOpen}>
          {children({ isOpen })}
        </TriggerWrapper>
      ) : (
        <Popover open={isOpen} onOpenChange={setIsOpen}>
          <PopoverTrigger asChild>{children({ isOpen })}</PopoverTrigger>
          <PopoverContent
            animate={false}
            className="flex h-68 max-h-[min(30rem,var(--radix-popper-available-height))] overflow-hidden p-0"
          >
            <Command
              value={commandValue}
              onValueChange={setCommandValue}
              shouldFilter={shouldFilter}
              filter={filter}
              wrapper="none"
              className="flex flex-1 flex-col"
            >
              <CommandInput
                showSpinner={isPending}
                placeholder={commandInputPlaceholder}
                value={commandInputValue}
                onValueChange={(v) => {
                  commandInputValueOnChange?.(v);
                  requestAnimationFrame(() => {
                    scrollAreaRef.current?.scrollTo({ top: 0 });
                  });
                }}
              />
              <ScrollArea viewportRef={scrollAreaRef} className="flex flex-1 flex-col">
                <CommandList>
                  {items && (
                    <CommandEmpty className="text-muted-foreground flex items-center justify-start gap-2 px-2.5 py-2.5 leading-tight">
                      <CommandEmptyIcon className="size-4.5 shrink-0" />
                      <p className="min-w-0 shrink">{commandEmptyText}</p>
                    </CommandEmpty>
                  )}
                  <CommandGroup>
                    {!items &&
                      isPending &&
                      placeholderArray.map((_, index) => (
                        <CommandItem disabled key={index}>
                          <p className="bg-foreground animate-skeleton min-w-0 shrink rounded-md leading-tight">
                            Loading
                          </p>
                        </CommandItem>
                      ))}
                    {!items && !isPending && error && (
                      <ErrorCard className="rounded-md" message={error} />
                    )}
                    {items && CommandItemsPinned ? (
                      <CommandItemsPinned setIsOpen={setIsOpen} commandValue={value} />
                    ) : null}
                    {items &&
                      items.map((item) => (
                        <CommandItem
                          onSelect={(v) => {
                            onChange(v);
                            setIsOpen(false);
                          }}
                          value={item.value}
                          key={item.value}
                          className="group/item px-3"
                          data-checked={field.state.value === item.value ? true : undefined}
                        >
                          {CommandItemElement ? (
                            <CommandItemElement item={item} />
                          ) : (
                            <p className="min-w-0 shrink leading-tight">{item.label}</p>
                          )}
                          <CheckIcon
                            strokeWidth={2.5}
                            className="-mr-0.5 ml-auto size-4.5 opacity-0 group-data-checked/item:opacity-100"
                          />
                        </CommandItem>
                      ))}
                  </CommandGroup>
                </CommandList>
              </ScrollArea>
            </Command>
          </PopoverContent>
        </Popover>
      )}
      {!hideError &&
      (field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("mt-1 bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

type TAsyncDropdownMenuProps = TFieldProps & {
  items: TCommandItem[] | undefined;
  ItemIcon?: FC<{ className?: string; value: string }>;
  isPending: boolean;
  error: string | undefined;
  className?: string;
  classNameInfo?: string;
  classNameDropdownContent?: string;
  value: string;
  onChange: (value: string) => void;
  dropdownTitle?: string;
  dropdownMenuContentAlign?: Parameters<typeof DropdownMenuContent>["0"]["align"];
  children: ({ isOpen }: { isOpen: boolean }) => ReactNode;
};

function AsyncDropdownMenu({
  field,
  items,
  ItemIcon,
  isPending,
  error,
  dontCheckUntilSubmit,
  hideError,
  value,
  onChange,
  className,
  classNameInfo,
  classNameDropdownContent,
  dropdownTitle,
  dropdownMenuContentAlign,
  children,
}: TAsyncDropdownMenuProps) {
  const submissionAttempts = useStore(field.form.store, (state) => state.submissionAttempts);
  const isFormSubmitted = submissionAttempts > 0;

  const [isOpen, setIsOpen] = useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null);

  return (
    <div className={cn("flex flex-col", className)}>
      <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
        <DropdownMenuTrigger asChild>{children({ isOpen })}</DropdownMenuTrigger>
        <DropdownMenuContent
          animate={false}
          className={cn("w-[var(--radix-popper-anchor-width)]", classNameDropdownContent)}
          align={dropdownMenuContentAlign}
        >
          <ScrollArea viewportRef={scrollAreaRef}>
            {dropdownTitle && (
              <>
                <DropdownMenuLabel>{dropdownTitle}</DropdownMenuLabel>
                <DropdownMenuSeparator />
              </>
            )}
            <DropdownMenuGroup>
              {!items && !isPending && error && (
                <ErrorCard className="rounded-md" message={error} />
              )}
              {!items &&
                isPending &&
                placeholderArray.slice(0, 4).map((_, index) => (
                  <DropdownMenuItem disabled key={index}>
                    <p className="bg-foreground animate-skeleton min-w-0 shrink rounded-md leading-tight">
                      Loading
                    </p>
                  </DropdownMenuItem>
                ))}
              {items &&
                items.map((item) => (
                  <DropdownMenuItem
                    key={item.value}
                    onSelect={() => {
                      onChange(item.value);
                      setIsOpen(false);
                    }}
                    data-checked={value === item.value ? true : undefined}
                    className="group/item"
                  >
                    {ItemIcon && (
                      <ItemIcon className="-ml-0.5 size-5 shrink-0" value={item.value} />
                    )}
                    <p className="min-w-0 shrink leading-tight">{item.label}</p>
                    <CheckIcon
                      strokeWidth={2.5}
                      className="-mr-0.5 ml-auto size-4.5 opacity-0 group-data-checked/item:opacity-100"
                    />
                  </DropdownMenuItem>
                ))}
            </DropdownMenuGroup>
          </ScrollArea>
        </DropdownMenuContent>
      </DropdownMenu>
      {!hideError &&
      (field.state.meta.isTouched || isFormSubmitted) &&
      (field.state.meta.isBlurred || isFormSubmitted) &&
      (!dontCheckUntilSubmit || isFormSubmitted) &&
      field.state.meta.errors.length ? (
        <ErrorLine
          className={cn("mt-1 bg-transparent py-1.5 pl-1.5", classNameInfo)}
          message={field.state.meta.errors[0].message}
        />
      ) : null}
    </div>
  );
}

export const { useAppForm, withForm } = createFormHook({
  fieldComponents: {
    TextField: InputWithInfo,
    NumberField: InputWithInfo,
    TextareaWithTokens: TextareaWithTokensWithInfo,
    DomainInput,
    StorageSizeInput,
    AsyncCommandDropdown,
    AsyncDropdownMenu,
  },
  formComponents: {
    SubmitButton: Button,
  },
  fieldContext,
  formContext,
});

export const DomainFieldSchema = z.string().url();
